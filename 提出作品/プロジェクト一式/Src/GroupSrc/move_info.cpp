//============================================================================
// 
// ２０２５年５月１６日：移動情報クラスを作成する [move_info.cpp]
// Author : 椎名太陽
// 
//============================================================================

//****************************************************
// インクルードファイル
//****************************************************
#include "move_info.h"      // 元ヘッダ
#include "manager.h"        // マネージャー
#include "renderer.h"       // レンダラー
#include "input_keyboard.h" // キー入力情報
 
//****************************************************
// usingディレクティブ
//****************************************************
using namespace useful;

//============================================================================
// 
// publicメンバ
// 
//============================================================================

//============================================================================
// コンストラクタ
//============================================================================
CMove_Info::CMove_Info() :
	m_Move(VEC3_INIT),
	m_fInertia(1.0f),
	m_bUseMove(true),
	m_bUseInertia(false)
{

}

//============================================================================
// デストラクタ
//============================================================================
CMove_Info::~CMove_Info()
{

}

//============================================================================
// 更新
//============================================================================
void CMove_Info::Update(D3DXVECTOR3& Pos, CObject* pObj)
{
	// 動くなら
	if (m_bUseMove)
	{
		// 慣性計算
		CalcInertia();

		// 位置の更新
		Pos += m_Move * pObj->GetTimeScaleInfo()->GetTimeScale();
	}
}

//============================================================================
// 移動量設定
//============================================================================
void CMove_Info::SetMove(D3DXVECTOR3 Move)
{
	m_Move = Move;
}

//============================================================================
// 移動量取得
//============================================================================
const D3DXVECTOR3& CMove_Info::GetMove() const
{
	return m_Move;
}

//============================================================================
// 慣性設定
//============================================================================
void CMove_Info::SetInertia(float fInertia)
{
	m_fInertia = fInertia;
}

//============================================================================
// 慣性取得
//============================================================================
const float& CMove_Info::GetInertia() const
{
	return m_fInertia;
}

//============================================================================
// 移動するかどうか設定
//============================================================================
void CMove_Info::SetUseMove(bool bUse)
{
	m_bUseMove = bUse;
}

//============================================================================
// 移動するかどうか取得
//============================================================================
const bool& CMove_Info::GetUseMove() const
{
	return m_bUseMove;
}

//============================================================================
// 慣性を使用するかどうか設定
//============================================================================
void CMove_Info::SetUseInertia(bool bUse)
{
	m_bUseInertia = bUse;
}

//============================================================================
// 慣性を使用するかどうか取得
//============================================================================
const bool& CMove_Info::GetUseInertia() const
{
	return m_bUseInertia;
}

//============================================================================
// 情報操作
//============================================================================
void CMove_Info::ControlInfo()
{
	CInputKeyboard* pInputKeyboard = CManager::GetManager()->GetKeyboard(); // キー入力情報

	// それぞれの移動量を更新（全ての軸でLシフトを押しながらだと値をマイナスにすることが出来ます）

	if (pInputKeyboard->GetPress(DIK_LSHIFT))
	{
		if (pInputKeyboard->GetTrigger(DIK_1))
		{
			m_Move.x -= 0.1f;
		}
	}
	else
	{
		if (pInputKeyboard->GetTrigger(DIK_1))
		{
			m_Move.x += 0.1f;
		}
	}

	if (pInputKeyboard->GetPress(DIK_LSHIFT))
	{
		if (pInputKeyboard->GetTrigger(DIK_2))
		{
			m_Move.y -= 0.1f;
		}
	}
	else
	{
		if (pInputKeyboard->GetTrigger(DIK_2))
		{
			m_Move.y += 0.1f;
		}
	}

	if (pInputKeyboard->GetPress(DIK_LSHIFT))
	{
		if (pInputKeyboard->GetTrigger(DIK_3))
		{
			m_Move.z -= 0.1f;
		}
	}
	else
	{
		if (pInputKeyboard->GetTrigger(DIK_3))
		{
			m_Move.z += 0.1f;
		}
	}

	// デバッグ表示
	CRenderer::SetDebugString("移動量編集：X(1)、Y(2)、Z(3)：X = " + to_string(m_Move.x) + "、Y = " + to_string(m_Move.y) + "、Z = " + to_string(m_Move.z));
}

//============================================================================
// 
// privateメンバ
// 
//============================================================================

//============================================================================
// 慣性計算処理
//============================================================================
void CMove_Info::CalcInertia()
{
	// 慣性を使用するなら
	if (m_bUseInertia)
	{
		// 慣性反映
		m_Move.x += (0.0f - m_Move.x) * m_fInertia;
		m_Move.y += (0.0f - m_Move.y) * m_fInertia;
		m_Move.z += (0.0f - m_Move.z) * m_fInertia;
	}
}
