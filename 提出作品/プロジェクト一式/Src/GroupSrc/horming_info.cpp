//============================================================================
// 
// ２０２５年５月２３日：ホーミングクラスを作成する [Horming_info.cpp]
// Author : 椎名太陽
// 
//============================================================================

//****************************************************
// インクルードファイル
//****************************************************
#include "horming_info.h"   // 元ヘッダ
#include "manager.h"        // マネージャー
#include "renderer.h"       // レンダラー
#include "input_keyboard.h" // キー入力情報
#include "calculation.h"    // 計算用
#include "gameplayer.h"     // プレイヤー

//****************************************************
// usingディレクティブ
//****************************************************
using namespace useful;

//============================================================================
// 
// publicメンバ
// 
//============================================================================

//============================================================================
// コンストラクタ
//============================================================================
CHorming_Info::CHorming_Info() :
	m_GoalPos{VEC3_INIT},
	m_Move{VEC3_INIT},
	m_fAdjust{0.0f},
	m_fAddAdjust{0.0f},
	m_fSpeed{0.0f},
	m_fAddSpeed{0.0f},
	m_bUse{false},
	m_fYaw{0.0f},
	m_fPitch{0.0f},
	m_LockOnType{LOCKONTYPE::NONE}
{

}

//============================================================================
// デストラクタ
//============================================================================
CHorming_Info::~CHorming_Info()
{

}

//============================================================================
// 更新処理
//============================================================================
const D3DXVECTOR3& CHorming_Info::Update(D3DXVECTOR3& Pos, CObject* pObj)
{
	// === 処理 ===

	// 使用するなら
	if (m_bUse)
	{
		// === 処理 ===
		switch (m_LockOnType)
		{
		case LOCKONTYPE::PLAYER:
			LockOnPlayer(pObj);
			break;
		default:
			break;
		}

		// 速度を加速させる
		m_fSpeed += m_fAddSpeed;

		// 補正度を加算させる
		m_fAdjust += m_fAddAdjust;

		CalcYaw(Pos,pObj);   // Yawを計算
		CalcPitch(Pos,pObj); // Pitchを計算

		// 移動する角度を計算
		m_Move = { sinf(m_fYaw) * cosf(m_fPitch),
				   sinf(m_fPitch),
				   cosf(m_fYaw) * cosf(m_fPitch) };

		// 移動する角度に速度をかける
		m_Move *= m_fSpeed;

		return m_Move;
	}
	return VEC3_INIT;
}

//============================================================================
// 目標位置取得
//============================================================================
const D3DXVECTOR3& CHorming_Info::GetGoalPos() const
{
	return m_GoalPos;
}

//============================================================================
// 目標位置設定
//============================================================================
void CHorming_Info::SetGoalPos(D3DXVECTOR3 GoalPos)
{
	m_GoalPos = GoalPos;
}

//============================================================================
// 移動量取得
//============================================================================
const D3DXVECTOR3& CHorming_Info::GetMove() const
{
	return m_Move;
}

//============================================================================
// 移動量設定
//============================================================================
void CHorming_Info::SetMove(D3DXVECTOR3 Move)
{
	m_Move = Move;
}

//============================================================================
// 補正値取得
//============================================================================
const float& CHorming_Info::GetAdjust() const
{
	return m_fAdjust;
}

//============================================================================
// 補正値設定
//============================================================================
void CHorming_Info::SetAdjust(float fAdjust)
{
	m_fAdjust = fAdjust;
}

//============================================================================
// 速度取得
//============================================================================
const float& CHorming_Info::GetSpeed() const
{
	return m_fSpeed;
}

//============================================================================
// 速度設定
//============================================================================
void CHorming_Info::SetSpeed(float fSpeed)
{
	m_fSpeed = fSpeed;
}

//============================================================================
// この処理を使用するかどうか取得
//============================================================================
const bool& CHorming_Info::GetUseHorming() const
{
	return m_bUse;
}

//============================================================================
// この処理を使用するかどうか設定
//============================================================================
void CHorming_Info::SetUseHorming(bool bUse)
{
	m_bUse = bUse;
}

//============================================================================
// Yaw値取得
//============================================================================
const float& CHorming_Info::GetYaw() const
{
	return m_fYaw;
}

//============================================================================
// Yaw値設定
//============================================================================
void CHorming_Info::SetYaw(float fYaw)
{
	m_fYaw = fYaw;
}

//============================================================================
// Pitch値取得
//============================================================================
const float& CHorming_Info::GetPitch() const
{
	return m_fPitch;
}

//============================================================================
// Pitch値設定
//============================================================================
void CHorming_Info::SetPitch(float fPitch)
{
	m_fPitch = fPitch;
}

//============================================================================
// 加算速度取得
//============================================================================
const float& CHorming_Info::GetAddSpeed() const
{
	return m_fAddSpeed;
}

//============================================================================
// 加算速度設定
//============================================================================
void CHorming_Info::SetAddSpeed(float fAddSpeed)
{
	m_fAddSpeed = fAddSpeed;
}

//============================================================================
// 加算補正値取得
//============================================================================
const float& CHorming_Info::GetAddAdjust() const
{
	return m_fAddAdjust;
}

//============================================================================
// 加算補正値設定
//============================================================================
void CHorming_Info::SetAddAdjust(float fAddAdjust)
{
	m_fAddAdjust = fAddAdjust;
}

//============================================================================
// 狙うオブジェクト種類取得
//============================================================================
const CHorming_Info::LOCKONTYPE& CHorming_Info::GetLockOnType() const
{
	return m_LockOnType;
}

//============================================================================
// 狙うオブジェクト種類設定
//============================================================================
void CHorming_Info::SetLockOnType(LOCKONTYPE TargetType)
{
	m_LockOnType = TargetType;
}

//============================================================================
// 
// privateメンバ
// 
//============================================================================

//============================================================================
// Yaw計算
//============================================================================
void CHorming_Info::CalcYaw(D3DXVECTOR3& Pos, CObject* pObj)
{
	// === 変数 ===

	D3DXVECTOR3 Vec = m_GoalPos - Pos; // 目的地とのベクトル
	float fGoalYaw = atan2f(Vec.x, Vec.z); // 目的のYaw
	float fYawDiff = Calculation::Rot::AdjustAngleDifference(m_fYaw, fGoalYaw); // 目的のYawとの差分を求める

	// === 処理 ===

	Calculation::Rot::Adjust(fYawDiff); // Yaw値の差を近い方に調整
	m_fYaw += fYawDiff * m_fAdjust; // 徐々に目的のYaw値へ合わせていく
	Calculation::Rot::Adjust(m_fYaw); // Yaw値を近い方に調整

}

//============================================================================
// Pitch計算
//============================================================================
void CHorming_Info::CalcPitch(D3DXVECTOR3& Pos, CObject* pObj)
{
	// === 変数 ===

	D3DXVECTOR3 Vec = m_GoalPos - Pos; // 目的地とのベクトル
	float fGoalPitch = atan2f(Vec.y,sqrtf(powf(Vec.x,2) + powf(Vec.z,2))); // 目的のPitch
	float fPicthDiff = Calculation::Rot::AdjustAngleDifference(m_fPitch, fGoalPitch); // 目的のPitchとの差分を求める

	// === 処理 ===

	Calculation::Rot::Adjust(fPicthDiff); // Pitch値の差を近い方に調整
	m_fPitch += fPicthDiff * m_fAdjust; // 徐々に目的のPitch値へ合わせていく
	Calculation::Rot::Adjust(m_fPitch); // Pitch値を近い方に調整
}

//============================================================================
// プレイヤーを狙う
//============================================================================
void CHorming_Info::LockOnPlayer(CObject* pObj)
{
	// プレイヤーオブジェクトを検索
	CObject* pSelfObj = CObject::FindSpecificObject(CObject::TYPE::PLAYER);

	// オブジェクトが存在したら
	if (pSelfObj)
	{
		CPlayer* pPlayer = hws::DownCast<CPlayer, CObject>(pSelfObj);

		m_GoalPos = pPlayer->GetPos(); // 目的地をプレイヤーにする
	}
}
